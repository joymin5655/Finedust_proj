/**
 * Air Quality API Module - WAQI Integration
 * Fetches real-time PM2.5 data from World Air Quality Index (WAQI)
 * https://aqicn.org/api/
 */

class AirQualityAPI {
  constructor() {
    // WAQI API Configuration
    this.waqiBaseURL = 'https://api.waqi.info';
    this.waqiToken = null;
    
    // Cache configuration
    this.cache = new Map();
    this.cacheTimeout = 30 * 60 * 1000; // 30 minutes (WAQI updates hourly)
    
    // Load API token from config
    this.loadConfig();
  }

  /**
   * Load API configuration
   */
  async loadConfig() {
    try {
      // Try to load from config.js (generated by GitHub Actions)
      if (typeof WAQI_CONFIG !== 'undefined' && WAQI_CONFIG.token) {
        this.waqiToken = WAQI_CONFIG.token;
        console.log('‚úÖ WAQI API token loaded from config');
        return;
      }
      
      // Fallback: try to load from separate config file
      const response = await fetch('js/config.js');
      if (response.ok) {
        const text = await response.text();
        const match = text.match(/token:\s*['"]([^'"]+)['"]/);
        if (match && match[1]) {
          this.waqiToken = match[1];
          console.log('‚úÖ WAQI API token loaded from config file');
          return;
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not load WAQI token from config:', error.message);
    }
    
    // If no token found, try demo token (limited to 1000 requests/day)
    console.warn('‚ö†Ô∏è No WAQI token configured, using demo token (limited)');
    this.waqiToken = 'demo';
  }

  /**
   * Get cached data if available and not expired
   */
  getCachedData(key) {
    const cached = this.cache.get(key);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      console.log(`üì¶ Using cached data for ${key}`);
      return cached.data;
    }
    return null;
  }

  /**
   * Cache data with timestamp
   */
  setCachedData(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  /**
   * Fetch air quality data for a specific city by name
   * @param {string} cityName - City name (e.g., "Seoul", "Beijing")
   * @returns {Promise<Object>} Air quality data
   */
  async fetchCityData(cityName) {
    if (!this.waqiToken) {
      await this.loadConfig();
    }

    const cacheKey = `waqi_city_${cityName}`;
    const cached = this.getCachedData(cacheKey);
    if (cached) return cached;

    try {
      const url = `${this.waqiBaseURL}/feed/${encodeURIComponent(cityName)}/?token=${this.waqiToken}`;
      
      console.log(`üåê Fetching WAQI data for ${cityName}...`);
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`WAQI API error: ${response.status}`);
      }

      const result = await response.json();

      if (result.status === 'ok' && result.data) {
        const processedData = this.processWAQIData(result.data, cityName);
        this.setCachedData(cacheKey, processedData);
        return processedData;
      } else if (result.status === 'error') {
        console.warn(`WAQI error for ${cityName}:`, result.data);
        return null;
      }

      return null;
    } catch (error) {
      console.warn(`Failed to fetch WAQI data for ${cityName}:`, error.message);
      return null;
    }
  }

  /**
   * Fetch air quality data by geographic coordinates
   * @param {number} lat - Latitude
   * @param {number} lon - Longitude
   * @returns {Promise<Object>} Air quality data
   */
  async fetchGeoData(lat, lon) {
    if (!this.waqiToken) {
      await this.loadConfig();
    }

    const cacheKey = `waqi_geo_${lat.toFixed(2)}_${lon.toFixed(2)}`;
    const cached = this.getCachedData(cacheKey);
    if (cached) return cached;

    try {
      const url = `${this.waqiBaseURL}/feed/geo:${lat};${lon}/?token=${this.waqiToken}`;
      
      console.log(`üåê Fetching WAQI data for coordinates (${lat}, ${lon})...`);
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`WAQI API error: ${response.status}`);
      }

      const result = await response.json();

      if (result.status === 'ok' && result.data) {
        const processedData = this.processWAQIData(result.data);
        this.setCachedData(cacheKey, processedData);
        return processedData;
      }

      return null;
    } catch (error) {
      console.warn(`Failed to fetch WAQI data for coordinates:`, error.message);
      return null;
    }
  }

  /**
   * Process WAQI raw data into standardized format
   */
  processWAQIData(data, cityName = null) {
    const aqi = data.aqi || 0;
    
    // Extract PM2.5 value
    let pm25 = null;
    if (data.iaqi && data.iaqi.pm25) {
      pm25 = data.iaqi.pm25.v;
    } else if (data.aqi) {
      // If no specific PM2.5, use AQI as approximation
      pm25 = this.aqiToPM25(data.aqi);
    }

    return {
      cityName: cityName || data.city?.name || 'Unknown',
      stationName: data.city?.name || 'Unknown Station',
      aqi: aqi,
      aqiLevel: this.getAQILevel(aqi),
      pm25: pm25,
      pm10: data.iaqi?.pm10?.v || null,
      coordinates: {
        lat: data.city?.geo?.[0] || null,
        lon: data.city?.geo?.[1] || null
      },
      timestamp: data.time?.iso || new Date().toISOString(),
      dominantPollutant: data.dominentpol || 'pm25',
      attribution: data.attributions || [],
      url: data.city?.url || null
    };
  }

  /**
   * Fetch data for multiple cities in a country
   * @param {Array<string>} cities - Array of city names
   * @returns {Promise<Object>} Aggregated data for the country
   */
  async fetchMultipleCities(cities) {
    const results = await Promise.allSettled(
      cities.map(city => this.fetchCityData(city))
    );

    const validData = results
      .filter(r => r.status === 'fulfilled' && r.value !== null)
      .map(r => r.value);

    if (validData.length === 0) {
      return null;
    }

    // Calculate country-level statistics
    const pm25Values = validData
      .filter(d => d.pm25 !== null)
      .map(d => d.pm25);

    const aqiValues = validData.map(d => d.aqi);

    return {
      citiesCount: validData.length,
      avgPM25: pm25Values.length > 0 
        ? pm25Values.reduce((a, b) => a + b, 0) / pm25Values.length 
        : null,
      maxPM25: pm25Values.length > 0 ? Math.max(...pm25Values) : null,
      minPM25: pm25Values.length > 0 ? Math.min(...pm25Values) : null,
      avgAQI: aqiValues.reduce((a, b) => a + b, 0) / aqiValues.length,
      cities: validData
    };
  }

  /**
   * Convert AQI to approximate PM2.5 (¬µg/m¬≥)
   * Using EPA AQI breakpoints
   */
  aqiToPM25(aqi) {
    if (aqi <= 50) {
      return (aqi / 50) * 12;
    } else if (aqi <= 100) {
      return 12 + ((aqi - 50) / 50) * 23.4;
    } else if (aqi <= 150) {
      return 35.4 + ((aqi - 100) / 50) * 19.6;
    } else if (aqi <= 200) {
      return 55 + ((aqi - 150) / 50) * 95;
    } else if (aqi <= 300) {
      return 150 + ((aqi - 200) / 100) * 100;
    } else {
      return 250 + ((aqi - 300) / 200) * 250;
    }
  }

  /**
   * Get AQI level category
   */
  getAQILevel(aqi) {
    if (aqi <= 50) return 'Good';
    if (aqi <= 100) return 'Moderate';
    if (aqi <= 150) return 'Unhealthy for Sensitive Groups';
    if (aqi <= 200) return 'Unhealthy';
    if (aqi <= 300) return 'Very Unhealthy';
    return 'Hazardous';
  }

  /**
   * Update policy data with real-time WAQI information
   */
  updatePolicyDataWithRealTime(policyData, waqiData) {
    if (!waqiData) return;

    policyData.realTimeData = policyData.realTimeData || {};
    policyData.realTimeData.currentPM25 = waqiData.avgPM25 || waqiData.pm25;
    policyData.realTimeData.aqi = Math.round(waqiData.avgAQI || waqiData.aqi);
    policyData.realTimeData.aqiLevel = this.getAQILevel(policyData.realTimeData.aqi);
    policyData.realTimeData.lastUpdated = new Date().toISOString();
    
    if (waqiData.cities) {
      policyData.realTimeData.majorCities = waqiData.cities.slice(0, 5).map(city => ({
        name: city.cityName,
        pm25: city.pm25,
        aqi: city.aqi,
        aqiLevel: city.aqiLevel
      }));
    }
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = AirQualityAPI;
}
